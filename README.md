````markdown
# SQL Study Repository: 종합 가이드

Oracle SQL의 핵심 개념을 학습하고 실습할 수 있도록 구성된 종합적인 가이드입니다. 기본적인 `SELECT` 구문부터 데이터베이스 객체 관리에 이르기까지, 각 주제에 대한 상세한 설명과 실용적인 예제 코드를 포함하고 있습니다.

---

## 목차

1.  **기본 SELECT 구문**: 데이터 조회의 기초
2.  **WHERE 절**: 데이터 필터링과 정렬
3.  **SQL 내장 함수**: 데이터 가공 및 처리
    * 문자열 함수
    * 숫자 함수
    * 날짜 함수
    * 데이터 변환 함수
    * NULL 처리 및 조건부 함수
4.  **그룹 함수와 GROUP BY**: 데이터 집계 및 분석
5.  **집합 연산자**: 쿼리 결과 합치기
6.  **JOIN**: 여러 테이블 데이터 연결
7.  **서브쿼리 (Subquery)**: 쿼리 속의 쿼리
8.  **DML (데이터 조작어)**: 데이터 삽입, 수정, 삭제
9.  **트랜잭션 (Transaction)**: 작업 단위 제어
10. **DDL (데이터 정의어)**: 데이터베이스 객체 생성 및 관리
11. **제약 조건 (Constraints)**: 데이터 무결성 보장
12. **뷰 (View)**: 가상 테이블 활용
13. **시퀀스(Sequence)와 인덱스(Index)**: 자동 번호 생성과 검색 성능 향상
14. **사용자 계정 및 권한**: 데이터베이스 접근 제어

---

### 1. 기본 SELECT 구문: 데이터 조회의 기초

데이터베이스에서 원하는 정보를 가져오는 가장 기본적인 명령어입니다.

* **컬럼 선택**: `SELECT` 키워드 뒤에 원하는 컬럼 이름을 쉼표로 구분하여 나열합니다. 모든 컬럼을 조회하려면 와일드카드(`*`)를 사용합니다.
* **별칭 (Alias)**: 컬럼 이름 바로 뒤에 `AS` 키워드나 공백을 사용하여 임시 이름을 부여할 수 있습니다. 별칭에 공백이나 특수문자가 포함될 경우 큰따옴표(`" "`)로 감싸줍니다. 이는 결과의 가독성을 높여줍니다.
* **산술 연산**: 숫자 타입의 컬럼은 `+`, `-`, `*`, `/` 같은 산술 연산자를 사용하여 새로운 값을 계산할 수 있습니다.
* **문자열 연결**: `||` 연산자를 사용하여 여러 컬럼이나 문자열 리터럴을 하나의 문자열로 합칠 수 있습니다.
* **중복 제거**: `DISTINCT` 키워드를 `SELECT` 바로 뒤에 사용하면, 조회 결과에서 완전히 동일한 행들을 하나만 남기고 제거합니다.
* **의사 컬럼 (Pseudo Columns)**: `ROWID`(데이터의 물리적 주소값)나 `ROWNUM`(조회된 순서에 붙는 일련번호)처럼 테이블에 실제 존재하지 않지만 사용할 수 있는 특별한 컬럼입니다.

**예제:**

```sql
-- EMPLOYEES 테이블에서 이름, 급여, 그리고 급여에 12를 곱한 연봉을 조회합니다.
-- 연봉 컬럼에는 "Annual Salary"라는 별칭을 부여합니다.
SELECT
    FIRST_NAME,
    SALARY,
    SALARY * 12 AS "Annual Salary"
FROM
    EMPLOYEES;
````

-----

### 2\. WHERE 절: 데이터 필터링과 정렬

`WHERE` 절은 `FROM` 절 다음에 위치하며, 특정 조건을 만족하는 행들만 선택하여 필터링하는 역할을 합니다.

  * **조건 연산자**: 다양한 연산자를 조합하여 복잡한 조건을 만들 수 있습니다.
      * **비교**: `=`, `>`, `<`, `>=`, `<=`, `<>` (같지 않음)
      * **범위**: `BETWEEN 값1 AND 값2` (값1 이상, 값2 이하)
      * **리스트**: `IN (값1, 값2, ...)` (리스트에 포함된 값과 일치)
      * **패턴 매칭**: `LIKE` (`_`: 한 글자, `%`: 여러 글자)
      * **NULL**: `IS NULL`, `IS NOT NULL` (NULL은 `=` 연산자로 비교할 수 없습니다)
  * **논리 연산자**: `AND`, `OR`, `NOT`을 사용하여 여러 조건을 결합합니다. `AND`가 `OR`보다 우선순위가 높으므로, `OR` 조건을 먼저 실행하고 싶을 때는 괄호`()`로 묶어주어야 합니다.
  * **정렬**: `ORDER BY` 절은 `SELECT` 문의 가장 마지막에 위치하며, 결과 집합을 특정 컬럼 기준으로 정렬합니다. `ASC`는 오름차순(기본값), `DESC`는 내림차순입니다.

**예제:**

```sql
-- 2005년에 입사한 사원 중, 직무가 'SA_REP'이거나 급여가 5000 이상인 사원의 정보를
-- 급여가 높은 순으로 정렬하여 조회합니다.
SELECT *
FROM EMPLOYEES
WHERE HIRE_DATE LIKE '05%' AND (JOB_ID = 'SA_REP' OR SALARY >= 5000)
ORDER BY SALARY DESC;
```

-----

### 3\. SQL 내장 함수: 데이터 가공 및 처리

SQL은 데이터를 효과적으로 가공하고 처리할 수 있는 다양한 내장 함수를 제공합니다.

#### 문자열 함수

문자열 데이터를 조작합니다.

  * `LOWER()`, `UPPER()`, `INITCAP()`: 영문 대소문자를 변환합니다.
  * `SUBSTR(문자열, 시작위치, 길이)`: 문자열의 일부를 추출합니다.
  * `LENGTH()`: 문자열의 길이를 바이트 단위로 반환합니다.
  * `INSTR(문자열, 찾을문자)`: 특정 문자가 처음 나타나는 위치를 찾습니다.
  * `LPAD()`, `RPAD()`: 문자열의 남는 공간을 특정 문자로 채웁니다.
  * `REPLACE(문자열, 이전문자, 새문자)`: 특정 문자열을 다른 문자열로 치환합니다.

#### 숫자 함수

수학적 계산을 수행합니다.

  * `ROUND(숫자, 자릿수)`: 지정된 자릿수에서 반올림합니다.
  * `TRUNC(숫자, 자릿수)`: 지정된 자릿수에서 버립니다.
  * `MOD(숫자1, 숫자2)`: 나눈 나머지를 구합니다.

#### 날짜 함수

날짜 및 시간 데이터를 처리합니다.

  * `SYSDATE`: 현재 데이터베이스 서버의 날짜와 시간을 반환합니다.
  * 날짜 간의 뺄셈은 일(day) 수를 반환하며, 날짜에 숫자를 더하거나 빼면 해당 일수만큼 이전/이후 날짜를 계산할 수 있습니다.

#### 데이터 변환 함수

데이터 타입을 명시적으로 변환합니다.

  * `TO_CHAR(날짜/숫자, '형식')`: 날짜나 숫자를 지정된 형식의 문자로 변환합니다.
  * `TO_DATE(문자, '형식')`: 날짜 형식의 문자를 실제 날짜 타입으로 변환합니다.
  * `TO_NUMBER(문자, '형식')`: 숫자 형식의 문자를 실제 숫자 타입으로 변환합니다.

#### NULL 처리 및 조건부 함수

조건에 따라 다른 값을 반환하거나 NULL 값을 처리합니다.

  * `NVL(컬럼, 값)`: 컬럼이 NULL일 경우 지정된 값으로 대체하는 가장 기본적인 함수입니다.
  * `DECODE(컬럼, 조건1, 결과1, ..., 기본값)`: Oracle 고유의 함수로, `IF-ELSEIF-ELSE`와 유사한 기능을 간단하게 구현합니다.
  * `CASE WHEN 조건 THEN 결과 ... ELSE 결과 END`: ANSI 표준 구문으로, `DECODE`보다 복잡하고 유연한 조건부 로직을 처리할 수 있습니다.

**예제:**

```sql
-- 사원의 급여 등급을 CASE 문을 사용하여 'High', 'Mid', 'Low'로 분류합니다.
SELECT
    FIRST_NAME,
    SALARY,
    CASE
        WHEN SALARY >= 10000 THEN 'High'
        WHEN SALARY >= 5000 THEN 'Mid'
        ELSE 'Low'
    END AS SALARY_GRADE
FROM
    EMPLOYEES;
```

-----

### 4\. 그룹 함수와 GROUP BY: 데이터 집계 및 분석

여러 행의 데이터를 특정 기준에 따라 그룹화하고, 각 그룹에 대한 집계 정보를 계산합니다.

  * **그룹 함수**:
      * `COUNT()`: 행의 개수를 셉니다.
      * `SUM()`: 합계를 구합니다.
      * `AVG()`: 평균을 구합니다.
      * `MAX()`, `MIN()`: 최대값과 최소값을 구합니다.
  * **GROUP BY**: `FROM`과 `WHERE` 절 뒤에 위치하며, 지정된 컬럼의 값이 같은 행들을 하나의 그룹으로 묶습니다. `SELECT` 절에는 `GROUP BY`에 사용된 컬럼과 그룹 함수만 사용할 수 있습니다.
  * **HAVING**: `GROUP BY` 절 뒤에 위치하며, 그룹화된 결과에 대한 조건을 지정하여 필터링합니다. 그룹 함수를 조건으로 사용할 수 있습니다.
  * \*\*ROLLUP` ,  `CUBE` **:  `GROUP BY`절 내에서 사용하여 그룹별 소계와 총계를 손쉽게 생성할 수 있습니다.`ROLLUP` 은 계층 구조의 소계를,  `CUBE\`는 모든 가능한 조합의 소계를 계산합니다.

**실행 순서**: `FROM` → `WHERE` → `GROUP BY` → `HAVING` → `SELECT` → `ORDER BY`

**예제:**

```sql
-- 각 부서별 평균 급여를 계산하되, 평균 급여가 5000달러 이상인 부서만 조회하고
-- 그 결과를 평균 급여가 높은 순으로 정렬합니다.
SELECT
    DEPARTMENT_ID,
    ROUND(AVG(SALARY)) AS AVG_SALARY
FROM
    EMPLOYEES
WHERE
    DEPARTMENT_ID IS NOT NULL
GROUP BY
    DEPARTMENT_ID
HAVING
    AVG(SALARY) >= 5000
ORDER BY
    AVG_SALARY DESC;
```

-----

### 5\. 집합 연산자: 쿼리 결과 합치기

두 개 이상의 `SELECT` 문의 결과 집합을 하나로 결합합니다. 이때 각 `SELECT` 문의 컬럼 개수와 데이터 타입이 일치해야 합니다.

  * `UNION`: 두 결과의 합집합을 반환하며, 중복된 행은 제거합니다.
  * `UNION ALL`: 두 결과의 합집합을 반환하며, 중복된 행을 모두 포함합니다. `UNION`보다 빠릅니다.
  * `INTERSECT`: 두 결과의 교집합, 즉 양쪽 모두에 존재하는 행만 반환합니다.
  * `MINUS`: 첫 번째 결과에서 두 번째 결과와 겹치는 행을 제외한 차집합을 반환합니다.

-----

### 6\. JOIN: 여러 테이블 데이터 연결

관계형 데이터베이스의 핵심 기능으로, 두 개 이상의 테이블을 공통된 키를 기준으로 연결하여 하나의 결과 집합으로 만듭니다. JOIN은 ANSI 표준 문법과 Oracle 전용 문법이 있습니다. **가독성과 데이터베이스 호환성을 위해 ANSI 표준 문법 사용이 권장됩니다.**

#### ANSI 표준 JOIN 문법 (권장)

`JOIN` 키워드를 `FROM` 절에 명시적으로 사용하고, `ON` 절에 조인 조건을 작성하는 방식입니다.

  * **INNER JOIN**: 양쪽 테이블에 모두 일치하는 데이터만 반환합니다. `INNER`는 생략 가능합니다.
    ```sql
    SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
    FROM EMPLOYEES E
    JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
    ```
  * **LEFT OUTER JOIN**: 왼쪽 테이블의 모든 행을 기준으로, 오른쪽 테이블의 일치하는 데이터를 연결합니다. `OUTER`는 생략 가능합니다.
    ```sql
    SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
    FROM EMPLOYEES E
    LEFT JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
    ```
  * **RIGHT OUTER JOIN**: 오른쪽 테이블의 모든 행이 기준이 됩니다.
    ```sql
    SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
    FROM EMPLOYEES E
    RIGHT JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
    ```
  * **FULL OUTER JOIN**: 양쪽 테이블의 모든 행을 반환하며, 일치하지 않는 부분은 NULL로 표시합니다.
  * **CROSS JOIN**: 두 테이블의 모든 가능한 행의 조합(카티시안 곱)을 반환합니다.

#### Oracle 전용 JOIN 문법

`FROM` 절에 테이블들을 쉼표로 나열하고, `WHERE` 절에 조인 조건을 작성합니다. OUTER JOIN은 `(+)` 기호를 사용합니다.

  * **INNER JOIN**:
    ```sql
    SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
    FROM EMPLOYEES E, DEPARTMENTS D
    WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;
    ```
  * **LEFT OUTER JOIN**: 데이터가 부족한 쪽(오른쪽 테이블)의 조인 조건 컬럼에 `(+)`를 붙입니다.
    ```sql
    SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
    FROM EMPLOYEES E, DEPARTMENTS D
    WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+);
    ```
  * **RIGHT OUTER JOIN**: 데이터가 부족한 쪽(왼쪽 테이블)의 조인 조건 컬럼에 `(+)`를 붙입니다.
    ```sql
    SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
    FROM EMPLOYEES E, DEPARTMENTS D
    WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID;
    ```

#### SELF JOIN

같은 테이블을 두 번 사용하여 자체적으로 조인합니다. 주로 사원과 관리자처럼 계층적인 구조를 가진 데이터를 조회할 때 유용합니다.

-----

### 7\. 서브쿼리 (Subquery): 쿼리 속의 쿼리

다른 SQL 문 내부에 포함된 `SELECT` 문으로, 복잡한 문제를 해결하기 위해 쿼리를 단계적으로 구성할 수 있게 해줍니다.

  * **단일 행(Single-Row) 서브쿼리**: 결과가 1행만 반환되며, `=`, `>`, `<` 등 단일 행 연산자와 사용됩니다.
  * **다중 행(Multi-Row) 서브쿼리**: 결과가 여러 행 반환될 수 있으며, `IN`, `ANY`, `ALL` 등 다중 행 연산자와 사용됩니다.
  * **스칼라(Scalar) 서브쿼리**: `SELECT` 절에서 사용되며, 반드시 단일 값(1행 1열)을 반환해야 합니다. `JOIN`을 대체하여 다른 테이블의 특정 컬럼 값을 가져올 때 간결하게 사용할 수 있습니다.
  * **인라인 뷰(Inline View)**: `FROM` 절에서 사용되며, 서브쿼리의 결과를 하나의 가상 테이블처럼 취급합니다. `ROWNUM`을 이용한 페이징 처리나 Top-N 분석 등 복잡한 분석 쿼리에 필수적입니다.

**예제 (인라인 뷰):**

```sql
-- 급여 순위 11위부터 20위까지의 사원을 조회합니다. (페이징 처리)
SELECT *
FROM (
    SELECT ROWNUM AS RN, A.*
    FROM (
        SELECT FIRST_NAME, SALARY
        FROM EMPLOYEES
        ORDER BY SALARY DESC
    ) A
)
WHERE RN BETWEEN 11 AND 20;
```

-----

### 8\. DML (데이터 조작어): 데이터 삽입, 수정, 삭제

테이블의 데이터를 직접 조작하는 명령어입니다. DML 실행 후에는 트랜잭션 관리가 필요합니다.

  * `INSERT`: 테이블에 새로운 행을 추가합니다. `INSERT INTO 테이블명 (컬럼...) VALUES (값...);`
  * `UPDATE`: `WHERE` 조건에 맞는 기존 행의 데이터를 수정합니다. `UPDATE 테이블명 SET 컬럼=값 WHERE 조건;`
  * `DELETE`: `WHERE` 조건에 맞는 행을 삭제합니다. `DELETE FROM 테이블명 WHERE 조건;`
  * `MERGE`: 조건에 따라 데이터가 있으면 `UPDATE`, 없으면 `INSERT`를 한 번에 수행합니다. 주로 두 테이블의 데이터를 동기화할 때 유용하게 사용됩니다.

-----

### 9\. 트랜잭션 (Transaction): 작업 단위 제어

하나의 논리적인 작업 단위를 의미합니다. 여러 DML 작업들을 하나의 트랜잭션으로 묶어 '전부 성공' 또는 '전부 실패'를 보장함으로써 데이터의 일관성과 안정성을 유지합니다.

  * `COMMIT`: 현재 트랜잭션의 모든 변경사항을 데이터베이스에 영구 저장하고 트랜잭션을 종료합니다.
  * `ROLLBACK`: 마지막 `COMMIT` 이후의 모든 변경사항을 취소하고 데이터를 이전 상태로 되돌립니다.
  * `SAVEPOINT`: 트랜잭션 내에 저장 지점을 만들어, 전체 트랜잭션을 `ROLLBACK`하는 대신 특정 지점까지만 되돌릴 수 있게 합니다.

-----

### 10\. DDL (데이터 정의어): 데이터베이스 객체 생성 및 관리

테이블, 뷰 등 데이터베이스 객체의 구조를 정의하고 관리하는 명령어입니다. DDL은 실행 즉시 자동 `COMMIT` 되므로 `ROLLBACK`이 불가능합니다.

  * `CREATE`: 테이블, 뷰, 인덱스 등 새로운 객체를 생성합니다.
  * `ALTER`: 기존 객체의 구조를 변경합니다 (`ADD`, `MODIFY`, `DROP COLUMN`).
  * `DROP`: 객체를 완전히 삭제합니다.
  * `TRUNCATE`: 테이블의 모든 행을 삭제하고 저장 공간을 반환합니다. `DELETE`보다 훨씬 빠르지만 `ROLLBACK`이 불가능합니다.

-----

### 11\. 제약 조건 (Constraints): 데이터 무결성 보장

테이블에 잘못된 데이터가 입력되는 것을 방지하고, 데이터의 정확성과 일관성을 유지하기 위한 규칙입니다.

  * `NOT NULL`: 해당 컬럼에 NULL 값이 입력되는 것을 허용하지 않습니다.
  * `UNIQUE`: 해당 컬럼의 모든 값이 유일해야 함을 보장합니다. (NULL은 허용)
  * **`PRIMARY KEY (PK)`**: `NOT NULL`과 `UNIQUE`의 특징을 모두 가집니다. 테이블의 각 행을 고유하게 식별하는 기본 키로, 테이블 당 하나만 지정 가능합니다.
  * **`FOREIGN KEY (FK)`**: 다른 테이블의 `PRIMARY KEY`를 참조하여 테이블 간의 관계를 설정합니다. 참조하는 테이블에 없는 값이 입력되는 것을 막아 '참조 무결성'을 보장합니다.
  * `CHECK`: 컬럼에 저장될 수 있는 값의 범위를 지정하거나 조건을 설정합니다.

-----

### 12\. 뷰 (View): 가상 테이블 활용

하나 이상의 실제 테이블을 기반으로 만들어진 가상의 논리적 테이블입니다. 실제 데이터는 원본 테이블에 저장되며, 뷰는 단지 저장된 쿼리 정의일 뿐입니다.

  * **장점**:
      * **쿼리 단순화**: 복잡한 조인이나 집계 쿼리를 뷰로 만들어두면, 이후에는 간단한 `SELECT` 문으로 해당 결과를 조회할 수 있습니다.
      * **보안**: 사용자에게 테이블 전체가 아닌, 뷰를 통해 허용된 특정 컬럼이나 행만 노출하여 데이터 접근을 제한할 수 있습니다.
  * **단순 뷰 vs 복합 뷰**: 하나의 테이블로 만든 단순 뷰는 일부 DML 작업이 가능하지만, 여러 테이블을 조인한 복합 뷰는 대부분 조회 전용(`READ ONLY`)으로 사용됩니다.

-----

### 13\. 시퀀스(Sequence)와 인덱스(Index): 자동 번호 생성과 검색 성능 향상

#### 시퀀스 (Sequence)

  * 연속적인 숫자를 자동으로 생성하는 데이터베이스 객체입니다. 주로 `PRIMARY KEY`에 중복되지 않는 값을 손쉽게 할당하기 위해 사용됩니다. 이러한 키를 '인조 식별자' 또는 '대리 키'라고 합니다.
  * `시퀀스명.NEXTVAL`: 다음 시퀀스 값을 가져옵니다.
  * `시퀀스명.CURRVAL`: 현재 세션에서 마지막으로 사용된 시퀀스 값을 확인합니다.

#### 인덱스 (Index)

  * 테이블의 특정 컬럼을 기준으로 데이터의 물리적 위치(주소)를 저장하는 자료구조입니다. 책의 '찾아보기'와 같은 역할을 하여 `SELECT` 문의 검색 속도를 획기적으로 향상시킵니다.
  * `PRIMARY KEY`와 `UNIQUE` 제약조건은 해당 컬럼에 자동으로 고유 인덱스를 생성합니다.
  * **장단점**: 조회(`SELECT`)는 빨라지지만, 데이터 변경(`INSERT`, `UPDATE`, `DELETE`) 시 인덱스도 함께 수정되어야 하므로 DML 작업 성능은 저하될 수 있습니다. 따라서 조회는 빈번하지만 데이터 변경은 적은 컬럼에 생성하는 것이 효율적입니다.

-----

### 14\. 사용자 계정 및 권한: 데이터베이스 접근 제어

데이터베이스의 보안을 위해 사용자 계정을 생성하고, 각 사용자에게 필요한 권한만 부여하여 접근을 통제합니다.

  * `CREATE USER`: 새로운 사용자 계정을 생성합니다.
  * `GRANT`: 사용자에게 특정 권한(데이터베이스 접속, 테이블 생성/조회/수정 등)이나 여러 권한을 묶어놓은 \*\*롤(Role)\*\*을 부여합니다.
      * **CONNECT Role**: 데이터베이스에 접속할 수 있는 기본 권한의 묶음입니다.
      * **RESOURCE Role**: 테이블, 시퀀스 등 주요 객체를 생성할 수 있는 권한의 묶음입니다.
  * `REVOKE`: 부여된 권한이나 롤을 회수합니다.
  * `ALTER USER`: 사용자의 비밀번호나 기본 테이블스페이스 등을 변경합니다.

<!-- end list -->

```
```
